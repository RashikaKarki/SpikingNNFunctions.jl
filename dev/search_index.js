var documenterSearchIndex = {"docs":
[{"location":"thresholds/#Threshold-Functions-1","page":"Thresholds","title":"Threshold Functions","text":"","category":"section"},{"location":"thresholds/#","page":"Thresholds","title":"Thresholds","text":"We provide non-mutating functions for the following threshold models:","category":"page"},{"location":"thresholds/#","page":"Thresholds","title":"Thresholds","text":"Inhomogenouos Poisson process","category":"page"},{"location":"thresholds/#","page":"Thresholds","title":"Thresholds","text":"SpikingNNFunctions.Threshold.poisson","category":"page"},{"location":"thresholds/#SpikingNNFunctions.Threshold.poisson","page":"Thresholds","title":"SpikingNNFunctions.Threshold.poisson","text":"poisson(baserate, theta, deltav, v; dt)\n\nEvaluate an array of inhomogeneous Poisson threshold functions. Use CuVector instead of Vector to evaluate on GPU.\n\nFields\n\nbaserate::Vector{<:Real}: base line firing rate\ntheta::Vector{<:Real}: nominal potential\ndeltav::Vector{<:Real}: potential deviation\nv::Vector{<:Real}: membrane potential\ndt::Real: simulation timestep\n\n\n\n\n\n","category":"function"},{"location":"synapses/#Synapse-Functions-1","page":"Synapses","title":"Synapse Functions","text":"","category":"section"},{"location":"synapses/#","page":"Synapses","title":"Synapses","text":"We provide non-mutating functions for the following synapse models:","category":"page"},{"location":"synapses/#","page":"Synapses","title":"Synapses","text":"Dirac-Delta\nAlpha\nExcited Postsynaptic Potential (EPSP)","category":"page"},{"location":"synapses/#","page":"Synapses","title":"Synapses","text":"SpikingNNFunctions.Synapse.delta\nSpikingNNFunctions.Synapse.alpha\nSpikingNNFunctions.Synapse.epsp","category":"page"},{"location":"synapses/#SpikingNNFunctions.Synapse.delta","page":"Synapses","title":"SpikingNNFunctions.Synapse.delta","text":"delta(t, lastspike, q)\n\nEvaluate a Dirac-delta synapse. Use CuVector instead of Vector for GPU support.\n\nFields\n\nt::Real: current time\nlastspike::Vector{<:Real}: last pre-synaptic spike time\nq::Vector{<:Real}: amplitude\n\n\n\n\n\n","category":"function"},{"location":"synapses/#SpikingNNFunctions.Synapse.alpha","page":"Synapses","title":"SpikingNNFunctions.Synapse.alpha","text":"alpha(t, lastspike, q, tau)\n\nEvaluate an alpha synapse. Use CuVector instead of Vector for GPU support.\n\nFields\n\nt::Real: current time\nlastspike::Vector{<:Real}: last pre-synaptic spike time\nq::Vector{<:Real}: amplitude\ntau::Vector{<:Real}: time constant\n\n\n\n\n\n","category":"function"},{"location":"synapses/#SpikingNNFunctions.Synapse.epsp","page":"Synapses","title":"SpikingNNFunctions.Synapse.epsp","text":"epsp(t, lastspike, q, tau)\n\nEvaluate an EPSP synapse. Use CuVector instead of Vector for GPU support.\n\nFields\n\nt::Real: current time\nlastspike::Vector{<:Real}: last pre-synaptic spike time\nq::Vector{<:Real}: amplitude\ntaum::Vector{<:Real}: rise time constant\ntaus::Vector{<:Real}: fall time constant\n\n\n\n\n\n","category":"function"},{"location":"neurons/#Neuron-Functions-1","page":"Neurons","title":"Neuron Functions","text":"","category":"section"},{"location":"neurons/#","page":"Neurons","title":"Neurons","text":"We provide in-place and non-mutating functions for the following neuron models:","category":"page"},{"location":"neurons/#","page":"Neurons","title":"Neurons","text":"Leaky-Integrate-and-Fire\nSimplified Spike Response Model (SRM0)","category":"page"},{"location":"neurons/#","page":"Neurons","title":"Neurons","text":"SpikingNNFunctions.Neuron.lif\nSpikingNNFunctions.Neuron.srm0","category":"page"},{"location":"neurons/#SpikingNNFunctions.Neuron.lif","page":"Neurons","title":"SpikingNNFunctions.Neuron.lif","text":"lif!(I, V; R, vreset, tau)\n\nEvaluate a leaky integrate-and-fire neuron. Use CuVector instead of Vector to evaluate on GPU.\n\nFields\n\nI::Vector{<:Real}: external current\nV::Vector{<:Real}: membrane potential\nR::Vector{<:Real}: resistance constant\nvreset::Vector{<:Real}: reset potential\ntau::Vector{<:Real}: time constant\n\n\n\n\n\n","category":"function"},{"location":"neurons/#SpikingNNFunctions.Neuron.srm0","page":"Neurons","title":"SpikingNNFunctions.Neuron.srm0","text":"srm0!(I, lastspike; eta)\n\nEvaluate a SRM0 neuron. Use CuVector instead of Vector to evaluate on GPU.\n\nFields\n\nI::Vector{<:Real}: external current\nlastspike::Vector{<:Real}: time of last output spike\neta::Vector{Function}: post-synaptic response function\n\n\n\n\n\n","category":"function"},{"location":"#SpikingNNFunctions.jl-1","page":"Home","title":"SpikingNNFunctions.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Fast spiking neural network primitive functions for use in other packages. The primary purpose of the package is to act as a dependency for SpikingNN.jl. Exctracting these primitives into their own package allows users to easily extend SpikingNN.jl (similar to NNlib.jl's role to Flux.jl).","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Functions are designed to dispatch on scalar arguments, array arguments, and CuArray arguments. So, the function should be available no matter what device you intend to run on.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For testing, refer to the SpikingNN.jl repo where these primitives are covered as part of testing.","category":"page"},{"location":"#Future-Work-1","page":"Home","title":"Future Work","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Using LoopVectorization.jl to speed up CPU implementations (currently this causes issues for AMD CPUs)\nExploring dispatch on sparse arrays","category":"page"}]
}
